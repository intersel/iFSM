<!DOCTYPE html>
<html>
<head>
    <title>iFSM in action! Bouncing Balls... </title>
	<meta charset="utf-8">
    <script type="text/javascript" src="../extlib/jquery-1.11.1.min.js"></script>
    <script type="text/javascript" src="../extlib/jquery.dotimeout.js"></script>
    <script type="text/javascript" src="../extlib/jquery.attrchange.js"></script>
    <script type="text/javascript" src="../extlib/jcanvas.min.js"></script>
    <script type="text/javascript" src="../extlib/Vector2.js"></script>
    <script type="text/javascript" src="../iFSM.js"></script>
	<style type="text/css">
	  html {
	    font-family: Helvetica, Arial, sans-serif;
	  }
	  body {
	    padding: 0 20px;
	  }
	  button {
	    margin: 0 2px;
	    font-size: 20px;
	    border: 1px solid #333;
	    width: 100px;
	    text-shadow: 0 -1px 0 #333;
	    border-radius: 5px;
	  }
	  pre {
		font-size: 12px;
		background-color: black;
		color: green;
	  }
	</style>
    <script type="text/javascript">
    
    var behaviourSubMachines = 
	{
    	listOfForces:
    	{
			submachine : {
				doProcessForces : 
				{
					GroundAttraction: 
					{
						init_function:function(){
							var target = new Vector2(this.opts.rootMachine.opts.Position.x,this.opts.rootMachine.opts.heightScreen);
							var desired_velocity = target.minusNew(this.opts.rootMachine.opts.Position).normalise();
							desired_velocity.multiplyEq(this.opts.rootMachine.opts.MaxVelocity).multiplyEq(this.opts.rootMachine.opts.Mass);
							this.opts.rootMachine.opts.SteeringForce.plusEq(desired_velocity.minusEq(this.opts.rootMachine.opts.Velocity));
							
						},
					},
					FleeBalls: 
					{
						init_function:function(){
							var target = new Vector2(this.opts.rootMachine.opts.Position.widthScreen,this.opts.rootMachine.opts.Position.y);
							var desired_velocity = target.minusNew(this.opts.rootMachine.opts.Position).normalise();
							desired_velocity.multiplyEq(this.opts.rootMachine.opts.MaxVelocity).multiplyEq(this.opts.rootMachine.opts.Mass);
							this.opts.rootMachine.opts.SteeringForce.plusEq(desired_velocity.minusEq(this.opts.rootMachine.opts.Velocity));
							
						},
					},
					BallElasticity : 
					{
						init_function:function(){
							if (this.opts.rootMachine.opts.Position.x + this.opts.rootMachine.opts.Velocity.x > this.opts.rootMachine.opts.widthScreen || this.opts.rootMachine.opts.Position.x + this.opts.rootMachine.opts.Velocity.x < 0)
								this.opts.rootMachine.opts.Velocity.x = -this.opts.rootMachine.opts.Velocity.x*.95;
								if (this.opts.rootMachine.opts.Position.y + this.opts.rootMachine.opts.Velocity.y > this.opts.rootMachine.opts.heightScreen || this.opts.rootMachine.opts.Position.y + this.opts.rootMachine.opts.Velocity.y < 0)
									this.opts.rootMachine.opts.Velocity.y = -this.opts.rootMachine.opts.Velocity.y*.9;
								
								this.opts.rootMachine.opts.Position.plusEq(this.opts.rootMachine.opts.Velocity);

						},
					},			
					ComputePosition : 
					{
						init_function:function(){
							//truncate steering force to a maximum 
							this.opts.rootMachine.opts.SteeringForce = this.opts.rootMachine.opts.SteeringForce.truncate(this.opts.rootMachine.opts.MaxSteeringForce);
							//adapt steering force according to the mass of the object
							this.opts.rootMachine.opts.SteeringForce = this.opts.rootMachine.opts.SteeringForce.divideEq(this.opts.rootMachine.opts.Mass);
							 
							//compute the new velocity and truncate it to a maximum speed
							this.opts.rootMachine.opts.Velocity.plusEq(this.opts.rootMachine.opts.SteeringForce).truncate(this.opts.rootMachine.opts.MaxSpeed);
							//compute the new position of the object
							this.opts.rootMachine.opts.Position.plusEq(this.opts.rootMachine.opts.Velocity);
							this.opts.rootMachine.opts.SteeringForce.reset(0,0);
						},
					},			
				},
				DefaultState:
				{
		    		doProcess: 
					{
						next_state:'doProcessForces',
						propagate_event:['GroundAttraction','BallElasticity','FleeBalls','ComputePosition','processed'],
					},
				},
			},
		},			
	}; 
    
    var aGameObject = {
    	WaitProcess:
		{
    		doInitDraw: 
			{
				init_function:function(p,e,data){
					if (this.opts.initdraw) this.opts.initdraw(this);
					this.opts.speedOfGame = data.aFSM.opts.speedOfGame;
					if (this.opts.noAnimation) this.trigger('noAnimation');
					},
			},
    		doProcess: 
			{
				next_state:'Processing',
				propagate_event:true,
			},
			noAnimation: 
			{
				next_state:'noAnimation',
			},
    	},
    	noAnimation:
    	{
    		//do nothing now...
    		doDraw: 
			{
    			init_function:function(p,e,data){
    				//gives a direct feedback
    				this.opts.alertSenderData=data;
					if (this.opts.alertSenderData.aEvent) 
						this.opts.alertSenderData.aFSM.trigger(this.opts.alertSenderData.aEvent);
    				},
			},
    	},
    	Processing:
		{
    		enterState: 
			{
				init_function:function(){
					//if (this.opts.process) this.opts.process(this);
					},
			},
			'delegate_machines'	: $.extend(true, {}, behaviourSubMachines),
			processed:
			{
				next_state:'WaitDraw',
			},
		},
		WaitDraw:
		{
			doDraw:
			{
				init_function:function(p,e,data){
					this.opts.alertSenderData=data;
					},
   				next_state:'Drawing',
   			},
		},
		Drawing:
		{
    		enterState: 
			{
				init_function:function(){
					if (this.opts.draw) this.opts.draw(this);
					else; 
						this.trigger('drawDone');
					},
				next_state:'WaitEndOfDrawing',
			},
		},
		WaitEndOfDrawing:
		{
			drawDone:
			{
				init_function:function(){
					if (this.opts.alertSenderData.aEvent) 
						this.opts.alertSenderData.aFSM.trigger(this.opts.alertSenderData.aEvent);
				},
				next_state:'WaitProcess',
			},
		},
        DefaultState        :
        {
            start:
            {
            	next_state: 'WaitProcess',
            },
            click:
            {
            	init_function:function(){
            		alert('object clicked!');
            	}
            },
            mousemove:
            {
            	init_function:function(p,e,layer){
            		$('#status').html('object over: '+layer.eventX+'/'+layer.eventY);
            	},
            },
            	
        }
    };
    
    var aGameRound = {
        	WaitStart:
    		{
        		enterState:
    			{
    				init_function:function()
   	    			{
						this._stateDefinition['NextRound']['doNextRound']['how_process_event'] = {delay: this.opts.speedOfGame};
	   					this.opts.nbFSMObjects = this.opts.gameFSMObjects.length;
	   					this.opts.counterIteration =0;
	   					this.trigger('displayGame');
    				}
    			},
   				StartStop: 
       			{
       				next_state:'PlayGame',
       				init_function:function(){
       					this.opts.lastcounterIteration=0;
    					this.trigger('displayFPS');
       				}
       			},
                displayFPS:'restartDisplayFPS',
                restartDisplayFPS:
                {
                },
                click:
                {
                	init_function:function(){
                		alert('canvas clicked!');
                	}
                }

        	},
        	PlayGame:
    		{
        		enterState: 
    			{
    				init_function:function(){
    					this.trigger('displayGame');
    				},
    				next_state:'WaitEndProcessing',
    			},
    		},
    		WaitEndProcessing:
   			{
    			EndDoDraw:
    			{
    				next_state_when:'this.EventIteration>=this.opts.nbFSMObjects',
       				next_state:'NextRound',
    			},
    		},
    		NextRound:
   			{
    			enterState:
    			{
    				init_function:function(){
    					this.myUIObject.drawLayers();
    				},
       				propagate_event:'doNextRound',
    			},
    			doNextRound:
    			{
       				how_process_event:{delay:10},
       				next_state:'PlayGame',
    			},
    		},
            DefaultState        :
            {
                start:
                {
                	init_function:function(){
    					var myFSM=this;
    					$.each(this.opts.gameFSMObjects,function(index,aFsmGame){
    						aFsmGame.trigger('doInitDraw',{aFSM:myFSM});
    					});
                	},
                	next_state: 'WaitStart',
                },
                StartStop:
                {
                	next_state:'WaitStart',
                },
                displayFPS:
                {
       				how_process_event:{delay:1000},
                	init_function:function(){
                		var aCount=this.opts.counterIteration-this.opts.lastcounterIteration;
                		this.opts.FPSCounter.html(aCount);
                		this.opts.lastcounterIteration=this.opts.counterIteration;
                		this.trigger('restartDisplayFPS');
                	}
                },
        		displayGame: 
    			{
    				init_function:function(){
    					//this.myUIObject.clearCanvas();
    					var myFSM=this;
    					$.each(this.opts.gameFSMObjects,function(index,aFsmGame){
    						aFsmGame.trigger('doProcess');
    						aFsmGame.trigger('doDraw',{aFSM:myFSM,aEvent:'EndDoDraw'});
    					});
    					this.opts.counterIteration++;
    					this.opts.counter.html(this.opts.counterIteration);
    				},
    			},
                restartDisplayFPS:
                {
                	propagate_event:'displayFPS',
                },
                /*mousemove:
                {
    				init_function:function(p,e,aLayer){
					  	if (aLayer) $('#status').html('mouse position: '+aLayer.eventX+'/'+aLayer.eventY);
    				}

                }*/
            }
        };

    /**
     * @param BasicStatesUI
     *  handles simple click event, that should be transfered 'toWho' with the 'sendWhat' event sent
     *  it is configured with its option parameters:
     *  @param toWho: 		a iFSM machine
     *  @param sendWhat: 	an event name
     *  @example $('#OkConnectionButton').iFSM(BasicStatesUI,{onClic:{toWho:ClicClacMachine,sendWhat:'okDoConnection'}});
     */

    var BasicStatesUI =
    {
    		Displayed:
    		{
    			enterState:
    			{
    				init_function: 
    	            	function(parameters, event, data)
    	            	{
    						this.myUIObject.show();
    	            	}
    			}	
    		},
    		Hidden:
    		{
    			enterState:
    			{
    				init_function: 
    		        	function(parameters, event, data)
    		        	{
    						this.myUIObject.hide();
    		        	}
    			},	
    		},
    		DefaultState:
    		{
    			click:
    			{
    				init_function: 
    	            	function(parameters, event, data)
    	            	{
    						this.opts.onClick.toWho.trigger(this.opts.onClick.sendWhat);
    	            	}
    			},
    			show:
    			{
    				next_state: 'Displayed'
    			},
    			hide:
    			{
    				next_state: 'Hidden'
    			},
    			start:
    			{
    				process_event_if: 'this.opts.startState != undefined',
    				init_function: 
    	            	function(parameters, event, data)
    	            	{
    						this.currentState = this.opts.startState;
    	            	},
    	            propagate_event_on_refused:'defaultState',
    			
    			},
    			defaultState:
    			{
    				next_state:'Displayed',
    			}
    		},
    }
    $(document).ready(function() {
    	
        aBackGroundGame = $('#aBackground').iFSM(aGameObject,{
										canvas:$('#canvas'),
        								color: '#FAF7F8',
        								width: 400,
        								height: 300,
        								noAnimation:true,
        								initdraw:function(aFSM){
        									aFSM.opts.canvas.drawRect({
       										  layer: true,
       										  name: aFSM.FSMName+'_background',
        									  fillStyle: aFSM.opts.color,
        									  x: 0, y: 0,
        									  width: aFSM.opts.width,
        									  height: aFSM.opts.height,
        									  fromCenter: false,
        									  mousemove:
        										  function(aLayer){
        										  	aFSM.trigger('mousemove',aLayer);
        										  	}
        									});},
        });
        
        function doProcessBall(aFSM){
			if (aFSM.opts.Position.x + aFSM.opts.Velocity.x > aFSM.opts.widthScreen || aFSM.opts.Position.x + aFSM.opts.Velocity.x < 0)
				aFSM.opts.Velocity.x = -aFSM.opts.Velocity.x;
				if (aFSM.opts.Position.y + aFSM.opts.Velocity.y > aFSM.opts.heightScreen || aFSM.opts.Position.y + aFSM.opts.Velocity.y < 0)
					aFSM.opts.Velocity.y = -aFSM.opts.Velocity.y;
				
				aFSM.opts.Position.plusEq(aFSM.opts.Velocity);
		};
		function doDrawBall(aFSM){
			aFSM.opts.canvas
			.setLayer(aFSM.FSMName+'_ball',{
				x: aFSM.opts.Position.x, 
				y: aFSM.opts.Position.y,
				}
			);
		};
		
		function doInitDrawBall(aFSM)
		{
			aFSM.opts.canvas.drawEllipse({
				  fillStyle: aFSM.opts.color,
				  x: aFSM.opts.Position.x, 
				  y: aFSM.opts.Position.y,
				  width: aFSM.opts.width,
				  height: aFSM.opts.height,
				  layer: true,
				  name: aFSM.FSMName+'_ball',
				  });
		}
        aBallGame = $('#aBall').iFSM(aGameObject,{
			canvas:$('#canvas'),
			color: '#770000',
			width: 20,
			height: 20,
			widthScreen:400,
			heightScreen:300,
			Position: new Vector2(200,100),
			Velocity: new Vector2(11,5),
			SteeringForce:new Vector2(0,0),
			MaxVelocity:4,
			MaxSteeringForce:0.1,
			MaxSpeed:30,
			Mass:1,
			initdraw:doInitDrawBall,
			process:doProcessBall,
			draw:doDrawBall,
		});
        
        a2ndBallGame = $('#aSecondBall').iFSM(aGameObject,{
			canvas:$('#canvas'),
			color: '#007777',
			width: 30,
			height: 30,
			widthScreen:400,
			heightScreen:300,
			Position: new Vector2(50,50),
			Velocity: new Vector2(30,15),
			SteeringForce:new Vector2(0,0),
			MaxVelocity:4,
			MaxSteeringForce:0.02,
			MaxSpeed:30,
			Mass:1,
			initdraw:doInitDrawBall,
			process:doProcessBall,
			draw:doDrawBall,
		});
        a3rdBallGame = $('#aThirdBall').iFSM(aGameObject,{
			canvas:$('#canvas'),
			color: '#007700',
			width: 10,
			height: 10,
			widthScreen:400,
			heightScreen:300,
			Position: new Vector2(250,250),
			Velocity: new Vector2(20,5),
			SteeringForce:new Vector2(0,0),
			MaxVelocity:4,
			MaxSteeringForce:0.07,
			MaxSpeed:30,
			Mass:1,
			initdraw:doInitDrawBall,
			process:doProcessBall,
			draw:doDrawBall,
		});
        
        var aObjectList=[aBackGroundGame,aBallGame,a2ndBallGame,a3rdBallGame];
        
        aGameFSM = $('#canvas').iFSM(aGameRound,{
			gameFSMObjects:aObjectList,
        	counter:$('#counter'),
        	FPSCounter:$('#FPSCounter'),
        	speedOfGame:1,
		});
        
        $('#StartStop').iFSM(BasicStatesUI,{onClick:{toWho:aGameFSM,sendWhat:'StartStop'}});
    });

    </script>
</head>
<body style="margin:20px;">
    <h1>The bouncing ball ....</h1>
    <p>this example shows a game loop, with bouncing balls as objects using canvas (jCanvas) with layers to display them</p>
 	<section>
	    <div>
	        <canvas id="canvas" width="400" height="300">
	         This text is displayed if your browser 
	         does not support HTML5 Canvas.
	        </canvas>
			<button class="onoff" id="StartStop">Start/Stop Game</button>
			<hr>
			<div>FrameCounter: <span id='counter'></span></div>	  
			<div>FPS: <span id='FPSCounter'></span></div>
			<div>Status: <span id='status'></span></div>
			<div id='aBackground'></div>
			<div id='aBall'></div>
			<div id='aSecondBall'></div>
			<div id='aThirdBall'></div>
	    </div>
 	</section>    

<pre>
</pre>    
</body>
</html>
