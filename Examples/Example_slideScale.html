<!DOCTYPE html>
<html>
<head>
<title>iFSM in action! a Finite State Machine for jQuery</title>
<script type="text/javascript" src="../extlib/jquery-3.2.0.min.js"></script>
<script type="text/javascript" src="../extlib/jquery.dorequesttimeout.js"></script>
<script type="text/javascript" src="../extlib/jquery.attrchange.js"></script>
<script type="text/javascript" src="../extlib/jquery.mousewheel.js"></script>
<script type="text/javascript" src="../extlib/jquery.touchSwipe.js"></script>
<script type="text/javascript" src="../iFSM.js"></script>
<style type="text/css">
html {
	font-family: Helvetica, Arial, sans-serif;
}

body {
	padding: 0 10px;
}

pre {
	font-size: 12px;
	background-color: black;
	color: green;
}

#cursor,#cursor2 {
	position: absolute;
	width:30px;
	height:50px;
	background-color: #AAA;
	margin:10px 0px;
}
#cursor.dragged,#cursor2.dragged {
	background-color: #CCC;
}

#cursorContainer,#cursorContainer2{
	position: relative;
	width:100%;
	height:70px;
	background-color: #404040;
	margin: 10px 0px;
}
#cursorContainer.dragged,#cursorContainer2.dragged {
	background-color: #505050;
}

#status,#status2 {
	margin: 10px;
}

</style>

<script type="text/javascript" id="iFSMscript">

$(document).ready(function() {
	
	$('#cursorContainer').iFSM(aSliderAnimation, {sticky:false,cursor:$('#cursor'),steps:5,alertObject:$( "#status" ),debugAnimation:true}); 
	$('#cursor').iFSM(aCursorAnimation); 
	$('#cursorContainer2').iFSM(aSliderAnimation, {sticky:true,cursor:$('#cursor2'),steps:51,alertObject:$( "#status2" ),debugAnimation:true}); 
	$('#cursor2').iFSM(aCursorAnimation); 
	
	var debug=true;
	$( "#status,#status2" ).on( 
	{
		"slideCursorMoveStart": function(e,posX) {
		  $(this).html( 'slideCursorMoveStart!' );
		  if (debug) console.log( 'slideCursorMoveStart!' );
		},
		"slideCursorMoveStop": function(e,posX) {
		  $(this).html( 'slideCursorMoveStop!' );
		  if (debug) console.log( 'slideCursorMoveStop!' );
		},
		"slideCursorMove": function(e,posX) {
		  //$(this).html( 'slideCursorMove:'+posX );
		  if (debug) console.log( 'slideCursorMove:'+posX );
		},
		"slideCursorMoveToStep": function(e,dataStep) {
		  $(this).html( 'slideCursorMoveToStep:'+dataStep.posX + ' - ' + dataStep.step+' - '+dataStep.cursor);
		  if (debug) console.log( 'slideCursorMoveToStep:'+dataStep.posX + ' - ' + dataStep.step );
		}
	});

});



var	docMachine= {
		DefaultState : {
			mouseup:{
				init_function:function(){
					this.opts.slider.trigger('mouseup');
				},
			},
			mousemove:	
			{
				init_function:function(p,e){
					this.opts.slider.trigger('mousemove',e);
				},
			}

		},
	};


/**
 * States to handle the click on buttons
 */
var aSliderAnimation = {

		waitToDragCursor: //in order to let the animation ends after its 500ms and to not cumulate multiple clicks
		{
			mousedown:	
			{
				init_function: function(p,e) {
					//init basic values of the slider
					this.opts['sliderWidth'] = this.myUIObject.outerWidth();
					this.opts['sliderMaxCursorPosX'] = this.myUIObject.outerWidth()-this.opts.cursor.outerWidth();
					this.opts['sliderHeight'] = this.myUIObject.outerHeight();
					this.opts['sliderLeft'] = this.myUIObject.offset().left;
					this.opts['sliderTop'] = this.myUIObject.offset().top;
					if (!this.opts.mouseWheelFactor)
					{
						if (this.opts.steps)
							this.opts.mouseWheelFactor = this.opts['sliderMaxCursorPosX'] / (this.opts.steps);
						else 
							this.opts.mouseWheelFactor = 10;
					}

					this.opts.eventPosition = {};
					this.opts.eventPosition['positionX'] = this.computeCursorPositionXFromDocToSlider(e.pageX);
					//this.opts['eventPosition']['positionY'] = this.computeCursorPositionYFromDocToSlider(e.pageY);;

				},
				next_state: 'initDragCursor', 
			},
			mousewheel:
			{
				init_function: function(p,e) {
					var delta = e.deltaY;
					delta *= this.opts.mouseWheelFactor;
					e.pageX=this.opts.cursor.offset().left+delta;
					this.trigger('mousedown',e);
					this.trigger('mousemove',e);
					if (this.opts.debugAnimation) console.log( 'pageX:'+e.pageX );

				},
				propagate_event:'mouseWheelUp',
			},
/*
//@todo: swipe implementation
			swipe:
			{
				init_function: function(p,e, direction, distance, duration, fingerCount, fingerData){
					var delta = e.deltaY;
					delta *= this.opts.mouseWheelFactor;
					e.pageX=this.opts.cursor.offset().left+delta;
					this.trigger('mousedown',e);
					this.trigger('mousemove',e);
					if (this.opts.debugAnimation) console.log( 'pageX:'+e.pageX );

				},
				propagate_event:'mouseWheelUp',
			},
*/
		},
		initDragCursor:
		{
			enterState:
			{
				init_function: function() {

				
					this.myUIObject.addClass('dragged');
					
					//position the cursor where we have clicked
					this.opts.cursor.trigger('setLeftX',this.computeCursorPositionXFromSliderToDoc(this.opts.eventPosition.positionX));
					this.opts.cursor.trigger('startDrag');
					
					this.opts.targetPosition  =  100 * this.opts.eventPosition.positionX/this.opts['sliderMaxCursorPosX'];
					
					this.opts.alertObject.trigger('slideCursorMoveStart');
				},
				next_state: 'dragCursor', 
			},
		},
		dragCursor: 
		{
			mouseup:	
			{
				init_function: function() {
					this.myUIObject.removeClass('dragged');
					this.opts.cursor.trigger('stopDrag');
				},
				next_state: 'moveCursorToFinal', 
			},
			mousemove:	
			{
				init_function: function(p,e,eDoc) {
					if (eDoc) e=eDoc;//comes from document...
					this.opts.nextCursorPosition = this.computeCursorPositionXFromDocToSlider(e.pageX);
					if (!this.opts.sticky) 
					{
						this.opts.cursor.trigger('setLeftX',this.computeCursorPositionXFromSliderToDoc(this.opts.nextCursorPosition));
					}
				},
				propagate_event:'sendEvent',
			},
			mouseWheelUp:
			{
				propagate_event:'mouseup',
				how_process_event :{delay:200},
			},
			sendEvent:
			{
				init_function: function() {
					var targetPosition;
					var stepFound = 0;

					var cursorPosX=this.opts.nextCursorPosition;
					var cursorPosXNormalized =  100 * cursorPosX/this.opts['sliderMaxCursorPosX'];

					if (this.opts.steps)
					{
					
						var OneStep = 100 / (this.opts.steps - 1);
						
						targetPosition = 0;
						
						var found = false;
						do{
							if ( 
										(cursorPosXNormalized  >= (targetPosition - OneStep/2) ) 
									&& 	(cursorPosXNormalized  <= (targetPosition + OneStep/2))
								)
								found = true;
							else
							{
								targetPosition += OneStep;
								stepFound ++;
							}
						}
						while(!found && targetPosition < 100);

						if (targetPosition != this.opts.targetPosition)
						{
							this.opts.alertObject.trigger('slideCursorMoveToStep',{posX:targetPosition/100,step:stepFound,cursor:cursorPosXNormalized});
							this.opts.targetPosition = targetPosition;
						}
						if (this.opts.sticky) 
						{
							var offsetX = targetPosition * this.opts['sliderMaxCursorPosX'] / 100;
							this.opts.cursor.trigger('setLeftX',this.computeCursorPositionXFromSliderToDoc(offsetX));
						}
						
					}
					
					this.opts.alertObject.trigger('slideCursorMove',cursorPosXNormalized/100);
					
				},
			},
		},				
		moveCursorToFinal: 
		{
			enterState:
			{
				init_function: function() {
					var targetPosition;
					var stepFound=0;
					var cursorPosX=this.computeCursorPositionXFromSliderToDoc(this.opts.cursor.offset().left-this.opts.sliderLeft+this.opts.cursor.outerWidth()/2);
					var cursorPosXNormalized =  100 * cursorPosX/this.opts['sliderMaxCursorPosX'];

					if (this.opts.steps)
					{
					
						var OneStep = 100 / (this.opts.steps - 1);
						
						targetPosition = 0;
						
						var found = false;
						do{
							if ( 
										(cursorPosXNormalized  >= (targetPosition - OneStep/2) ) 
									&& 	(cursorPosXNormalized  <= (targetPosition + OneStep/2))
								)
								found = true;
							else
							{
								targetPosition += OneStep;
								stepFound ++;
							}
						}
						while(!found && targetPosition < 100);
						
						var offsetX = targetPosition * this.opts['sliderMaxCursorPosX'] / 100;
						this.opts.cursor.trigger('setLeftX',this.computeCursorPositionXFromSliderToDoc(offsetX));
						
					}
					else
					{
						targetPosition = cursorPosXNormalized;
					}
					
					this.opts.alertObject.trigger('slideCursorMoveToStep',{posX:targetPosition/100,step:stepFound,cursor:cursorPosXNormalized});
					this.opts.alertObject.trigger('slideCursorMove',targetPosition/100);
					
					this.opts.alertObject.trigger('slideCursorMoveStop');

					
				},
				next_state: 'waitToDragCursor', 
			}
		},
		DefaultState:
		{
			start:	
			{
				init_function: function() {

					//to manage when the events are outside the slider
					$(document).iFSM(docMachine,{slider:this.myUIObject});
					
					var sliderOpts=this.opts;
					
					this.computeCursorPositionXFromDocToSlider = function (aPosXinDocument)
					{
						var posX = aPosXinDocument-sliderOpts.sliderLeft-sliderOpts.cursor.outerWidth()/2;
						posX = Math.max(Math.min(posX,this.opts.sliderMaxCursorPosX),0);
						if (this.opts.debugAnimation) this.opts.alertObject.html('posXSlider:'+posX);
						//limit the position of the cursor between 0 and slider width
						return posX;
						
					};
					this.computeCursorPositionXFromSliderToDoc = function (aPosXinSlider)
					{
						var posX = aPosXinSlider;
						//if (this.opts.debugAnimation) $('#status').html('posX:'+posX);
						return posX;
						
					};

					
				},
				next_state: 'waitToDragCursor'
			},
		}				
}
/**
 * States to handle the click on buttons
 */
var aCursorAnimation = {

		waitToBeDragged: //in order to let the animation ends after its 500ms and to not cumulate multiple clicks
		{
			startDrag:'mousedown',
			mousedown:	
			{
				init_function: function(p,e) {
					this.myUIObject.addClass('dragged');
				},
				next_state: 'dragged', 
				UI_event_bubble:true,
			},
		},				
		dragged: //in order to let the animation ends after its 500ms and to not cumulate multiple clicks
		{
			stopDrag:'mouseup',
			mouseup:	
			{
				init_function: function() {
					this.myUIObject.removeClass('dragged');
				},
				next_state: 'waitToBeDragged', 
				UI_event_bubble:true,
			},
		},				
		DefaultState:
		{
			start:	
			{
				init_function: function() {
					this.opts['sliderWidth'] = this.myUIObject.outerWidth();
					this.opts['sliderHeight'] = this.myUIObject.outerHeight();
				},
				next_state: 'waitToBeDragged'
			},
			setLeftX:
			{
				//posX considered at the middle of the object
				init_function: function(p,e,posX) {
					this.myUIObject.animate({
						left: parseFloat(posX),
					},0);
					if (this.opts.debugAnimation) $('#status').html('posX:'+posX);
				},

			},
		}				
}


 </script>
 </head>
<body style="margin:100px;">
	<h1>A (not so) simple slide scale driven with iFSM </h1>
	<p>This example shows an horizontal slider made up of a cursor and a background where the cursor moves.<p>
	<p>	Steps may be defined where the cursor should be set when the mouse button is released. </p>
	<p>Events that are sent to any listening objects are :</p>
	<ul>
		<li>"slideCursorMoveStart": cursor starts to move (mousedown)</li>
		<li>"slideCursorMoveStop": cursor was released (mouseup)</li>
		<li>"slideCursorMove": cursor moves along the slider</li>
		<li>"slideCursorMoveToStep": cursor is on a step of the slider</li>
	</ul>
	<h2>Slide with 5 steps (0 to 4) with no "sticky steps"</h2>
	<div id="cursorContainer">
		<div id="cursor"></div>
	</div>
	<div id="status"></div>
	<h2>Slide with 50 steps with "sticky steps"</h2>
	<div id="cursorContainer2">
		<div id="cursor2"></div>
	</div>
	<div id="status2"></div>
<br>
	<br>
	<br>
	<pre>
	<script>
		function escapeHtml(text) {
			var map = {
				'&': '&amp;',
				'<': '&lt;',
		    '>': '&gt;',
				'"': '&quot;',
				"'": '&#039;'
			};

			return text.replace(/[&<>"']/g, function(m) {
				return map[m];
			});
		}
		document.write(escapeHtml($('#iFSMscript').html()))
	</script>
    </pre>
	<p>
		provided by <a href="http://www.intersel.fr">Intersel</a>
	</p>
	</pre>
</body>
</html>
